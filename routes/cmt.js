const express = require("express");
const CMTconfig = require("../models/cmtConfig");
const { hasAccess } = require("./interceptor");
const router = express.Router();

/* This method will take all the 
information ragrding 
application , it will return appId as unique key for app/env
remember currentConfig will always be replaced by UI 
and history config will be pushed as audit record 
{
id: application id per env generated by API and required for future edits.
applicationName: pop
idToken: send by ui and will use it for auth
env: ftr/qa/prod
createdBy: ngupta
historyConfig: [] // this will be generated by api and Ui will need it for rollback
currentConfig: {
// this will be raw json
}
}
createdAt : this will be generated by API
*/

router.post("/save", async (req, res) => {
  // this is the save request so unique document will
  // be created.
  // make sure historyConfiguration are saved
  // make sure all the priorites are also set
  const dbObject = {
    applicationName: req.body.applicationName,
    env: req.body.env,
    createdBy: req.body.createdBy,
    historyConfig: [req.body.currentConfig],
    currentConfig: req.body.currentConfig,
    lastUpdatedBy: req.body.createdBy,
    lastUpdatedAt: new Date(),
    createdAt: new Date(),
    region: req.body.region,
  };
  const cmt = new CMTconfig(dbObject);
  const response = await cmt.save();

  res.send(response);
});

/* This will be the get request to get the configuration based on 
per app/env/region */
router.get("/get-config", async (req, res) => {
  try {
    if (!req.query._id) {
      throw new Error("Application id  is not configured");
    }
    const response = await CMTconfig.findOne(
      {_id: req.body._id}
    );
    res.send(response);
  } catch (e) {
    res.send({ error: e.message });
  }
});
/* This will give all the data for the application to show on the dasahsboard */

/* This will be the get request to get the configuration based on 
per app/env */
router.get("/get-all", async (req, res) => {
  try {
    const response = await CMTconfig.find({region:req.query.region});
    res.send(response);
  } catch (e) {
    res.send({ error: e.message });
  }
});

/* This end point will be used to rollback the config to certain point
per app/env */
router.post("/update-config", async (req, res) => {
  try {
    if (
      !req.body.lastUpdatedBy ||
      !req.body._id ||
      !req.body.applicationName ||
      !req.body.env ||
      !req.headers.idtoken
    ) {
      throw new Error(
        "Application name /id/lastupdatedby/token or env is not configured"
      );
    }
    const isAllow = await hasAccess(
      req.body._id,
      ["UPDATE"],
      req.body.env,
      req.headers.idtoken
    );
    if (isAllow) {
      throw new Error("You are not authorized to update the configuration");
    }
    const response = await CMTconfig.findOne({
      $and: [
        { applicationName: req.body.applicationName },
        { env: req.body.env },
        { _id: req.body._id },
      ],
    });

    if (response) {
      // application exists now update the configuration
      let { historyConfig } = response;
      historyConfig.push(req.body.currentConfig);
      const dbObject = {
        historyConfig: historyConfig,
        currentConfig: req.body.currentConfig,
        lastUpdatedBy: req.body.lastUpdatedBy,
        lastUpdatedAt: new Date(),
      };
      const updateResponse = await CMTconfig.findByIdAndUpdate(
        req.body._id,
        dbObject,
        { new: true }
      );

      res.send(updateResponse);
    } else {
      throw new Error("Application does not exists");
    }
  } catch (e) {
    
    res.send({ error: e.message });
  }
});

/* This will be the get request to get the configuration based on 
per app/env for the client will do overriden of properties*/
router.get("/get-client-config", async (req, res) => {
  try {
    if (!req.query.appId) {
      throw new Error("Application name or env is not configured");
    }
    const response = await CMTconfig.findOne({ _id: req.query.appId });
    // here we will merge all the config
    const mergeMap = new Map();
    const currentConfigObject = response.currentConfig || {};
    Object.keys(currentConfigObject).forEach((key) => {
     
      // get the key and get all object from that key
      Object.keys(currentConfigObject[key]).forEach((childKey) => {
        mergeMap.set(childKey, currentConfigObject[key][childKey]);
      });
    });
    const configObject = Object.fromEntries(mergeMap);
    response.currentConfig = configObject;
    res.send(response);
  } catch (e) {
    res.send({ error: e.message });
  }
});
module.exports = router;
